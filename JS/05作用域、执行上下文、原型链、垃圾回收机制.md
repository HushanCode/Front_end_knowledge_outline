# 文章

[详细总结](https://blog.csdn.net/m0_55221239/article/details/115313923)

# 补充

# 作用域

## 一、js中的词法作用域

在 JavaScript 中，词法作用域指的是在编写代码时，函数的作用域由函数所声明的位置来决定，而不是函数被调用时所在的位置。这意味着函数内部可以访问其外部作用域中定义的变量，而在函数外部则不能访问函数内部的变量。

JavaScript 的词法作用域意味着函数内部可以访问其外部作用域中定义的变量，是因为在函数被定义时，函数的作用域就已经确定了，也就是说，函数可以访问其定义时所处的作用域中的变量。

具体来说，当在 JavaScript 中定义一个函数时，函数的内部会创建一个作用域链，该作用域链包含了函数定义时所处的作用域以及其外部的所有作用域，直到全局作用域为止。在函数执行时，当函数需要访问一个变量时，JavaScript 引擎会先在当前函数的作用域中查找该变量，如果找不到，就会沿着作用域链往外查找，直到找到该变量或者到达全局作用域为止。

```js
var globalVar = "global";

function outerFunction() {
  var outerVar = "outer";
  
  function innerFunction() {
    var innerVar = "inner";
    console.log(globalVar); // 输出 "global"
    console.log(outerVar); // 输出 "outer"
    console.log(innerVar); // 输出 "inner"
  }
  
  innerFunction();
  
  console.log(globalVar); // 输出 "global"
  console.log(outerVar); // 输出 "outer"
  console.log(innerVar); // 报错，因为 innerVar 只在 innerFunction 内部定义
}

outerFunction();

console.log(globalVar); // 输出 "global"
console.log(outerVar); // 报错，因为 outerVar 只在 outerFunction 内部定义
console.log(innerVar); // 报错，因为 innerVar 只在 innerFunction 内部定义

```

在这个例子中，全局变量 `globalVar` 可以在所有函数内部访问，因为它是在全局作用域中定义的。变量 `outerVar` 只能在 `outerFunction` 函数内部访问，因为它是在该函数内部定义的。类似地，变量 `innerVar` 只能在 `innerFunction` 函数内部访问，因为它是在该函数内部定义的。



## 二、变量提升

变量提升是指在 JavaScript 中，变量和函数的声明会被提升到当前作用域的顶部，而不管实际的声明语句是在哪里执行的。这意味着，在变量和函数被声明之前，它们就已经可以在当前作用域中使用了。

具体来说，JavaScript 中的变量声明和函数声明都会被提升。变量声明的提升意味着可以在声明语句之前使用变量，但是此时变量的值为 `undefined`。函数声明的提升意味着可以在声明语句之前调用函数。

```js
console.log(a); // 输出 undefined
var a = 1;

foo(); // 输出 "Hello"
function foo() {
  console.log("Hello");
}
```

在这个例子中，变量 `a` 和函数 `foo` 都在使用之前被声明了，但是它们的实际声明语句在后面。由于变量和函数的声明被提升到了当前作用域的顶部，因此可以在声明语句之前使用它们。

需要注意的是，虽然变量和函数的声明会被提升，但是变量赋值和函数表达式不会被提升。例如：

```js
console.log(b); // 报错，b 没有被定义
b = 2;

bar(); // 报错，bar 不是一个函数
var bar = function() {
  console.log("World");
}
```

在这个例子中，变量 `b` 被赋值为 `2`，而不是被声明。因此，在使用 `b` 之前会报错。函数 `bar` 是一个函数表达式，而不是一个函数声明，因此不会被提升。在调用 `bar()` 时，由于 `bar` 不是一个函数，会报错。

JavaScript 中变量提升的规则如下：

1. 变量声明会被提升到当前作用域的顶部，但是变量赋值不会被提升。
2. 函数声明会被提升到当前作用域的顶部，包括函数名和函数体。函数表达式不会被提升。
3. 如果同时存在同名的变量声明和函数声明，函数声明会被优先提升。
4. 变量和函数的声明只会被提升到当前作用域的顶部，不会跨越作用域边界。



## 三、立即执行函数

立即执行函数（Immediately Invoked Function Expression，IIFE）是指定义后立即执行的匿名函数。它的形式通常是在函数表达式后紧跟一对括号，从而将其转换为函数调用。IIFE 可以用来创建一个独立的作用域，从而避免变量名冲突和全局变量的污染。

下面是一个简单的立即执行函数的例子：

```js
(function() {
  var message = "Hello, world!";
  console.log(message);
})();
```

```js
//将函数表达式用逻辑非运算符包裹起来，然后紧跟一对括号将它转换为函数调用
!function() {
  var message = "Hello, world!";
  console.log(message);
}();
```

在这个例子中，我们定义了一个匿名函数，然后在函数表达式后紧跟一对括号。这样就将这个匿名函数转换为一个函数调用，从而立即执行了这个函数。在这个立即执行函数内部，我们定义了一个局部变量 `message`，然后输出了它的值。由于这个变量是在立即执行函数内部定义的，它不会与全局作用域中的变量名产生冲突，从而实现了作用域隔离的效果。

**立即执行函数有什么用处？**

1. 创建独立的作用域：通过在函数内部定义变量和函数，可以避免变量名冲突和全局作用域的污染，从而增强代码的可读性、可维护性和安全性。

​	

```js
(function() {
  var x = 10;
  console.log(x); // 10
})();

console.log(x); // ReferenceError: x is not defined
```

在这个例子中，我们创建了一个立即执行函数，它包含一个名为 `x` 的局部变量。在函数外部，我们无法访问 `x` 变量，因为它的作用域仅限于函数内部。

 

2. 隐藏实现细节：通过将某些变量或函数作为 IIFE 的局部变量或局部函数，可以隐藏实现细节，避免泄露信息和污染全局命名空间。



```js
var myLibrary = (function() {
  var privateData = 'Hello, World!';

  function privateMethod() {
    console.log('This is a private method.');
  }

  return {
    publicData: 'Hi, there!',
    publicMethod: function() {
      console.log('This is a public method.');
      console.log('Private data:', privateData);
      privateMethod();
    }
  };
})();

console.log(myLibrary.publicData); // "Hi, there!"
myLibrary.publicMethod(); // "This is a public method." "Private data: Hello, World!" "This is a private method."
console.log(myLibrary.privateData); // undefined
myLibrary.privateMethod(); // TypeError: myLibrary.privateMethod is not a function

```

在这个例子中，我们创建了一个模块化的代码库，它包含一个立即执行函数和一些私有变量和函数。在函数内部，我们定义了一个名为 `privateData` 的私有变量和一个名为 `privateMethod` 的私有函数，它们都只能在函数内部访问。同时，我们还通过返回一个对象字面量，将一些公共成员暴露给外部代码访问。在返回的对象中，我们定义了一个名为 `publicData` 的公共变量和一个名为 `publicMethod` 的公共方法，它们都可以在外部代码中访问。通过这种方式，我们可以隐藏实现细节，避免直接访问和修改私有成员。

3. 保护代码库：通过将某些模块或类作为 IIFE 的返回值，可以将它们封装起来，避免外部代码直接访问和修改它们，从而保护代码库的完整性和稳定性。

```js
var myLibrary = (function() {
  var privateData = 'Hello, World!';

  function privateMethod() {
    console.log('This is a private method.');
  }

  function MyLibrary() {}

  MyLibrary.prototype.getPrivateData = function() {
    console.log(privateData);
  };

  return new MyLibrary();
})();

console.log(myLibrary.getPrivateData()); // "Hello, World!"
console.log(myLibrary.privateData); // undefined

```

在这个例子中，我们创建了一个包含私有变量和函数的类，并通过 `new` 关键字创建了一个实例对象并返回它。在返回的对象中，我们定义了一个名为 `getPrivateData` 的公共方法，它可以访问私有变量 `privateData`。通过这种方式，我们可以将类封装起来，避免外部代码直接访问和修改私有成员。

 

4. 提供私有成员：通过在 IIFE 中定义私有变量和函数，并将它们作为闭包的一部分，可以创建只有内部函数可以访问的私有成员，从而增强代码的封装性和安全性。

```js
var counter = (function() {
  var count = 0; // 私有变量

  // 返回一个对象
  return {
    increment: function() {
      count++;
    },
    getCount: function() {
      return count;
    }
  };
})();

// 调用公共方法
counter.increment();
console.log(counter.getCount()); // 输出 1
counter.increment();
console.log(counter.getCount()); // 输出 2

```

在这个例子中，我们创建了一个计数器类，并通过立即执行函数将计数器的初始值设为私有变量 `count`。在返回的对象中，我们定义了一个名为 `increment` 的公共方法和一个名为 `getCount` 的公共方法。公共方法 `increment` 可以将计数器的值加 1，而公共方法 `getCount` 则可以获取计数器的当前值。通过这种方式，我们可以将计数器的初始值隐藏起来，只提供一些公共接口供外部代码使用。在函数执行后，外部代码可以通过调用 `counter.increment()` 和 `counter.getCount()` 来操作计数器。

5. 改变变量的作用域：通过在 IIFE 中使用 `let` 或 `const` 关键字，可以将变量的作用域限制在块级作用域内，避免变量提升和意外的变量覆盖，从而增强代码的可靠性和健壮性。

变量的作用域是由函数和代码块来定义的，我们可以通过创建新的函数或者代码块来改变变量的作用域。下面是一些示例：

1. 通过创建新的函数改变变量的作用域：

```js
var x = 10;

(function() {
  var x = 20;
  console.log(x); // 输出 20
})();

console.log(x); // 输出 10
```

在这个例子中，我们创建了一个立即执行函数，该函数创建了一个新的作用域，并在其中定义了一个名为 `x` 的变量。由于在该函数内部定义了一个新的 `x` 变量，因此外部的 `x` 变量不会受到影响。

1. 通过创建代码块改变变量的作用域：

```js
var x = 10;

{
  let x = 20;
  console.log(x); // 输出 20
}

console.log(x); // 输出 10
```

在这个例子中，我们创建了一个代码块，并在其中使用 `let` 关键字定义了一个新的 `x` 变量。由于 `let` 关键字将变量的作用域限制在代码块内部，因此内部的 `x` 变量不会影响外部的 `x` 变量。注意，在这个例子中，我们使用了 `let` 关键字而不是 `var` 关键字来定义变量，因为 `let` 关键字可以创建块级作用域。



## 四、作用域安全的构造函数

作用域安全的构造函数是指一个能够确保在被当做普通函数调用时不会改变全局作用域（即 `this` 关键字指向全局对象）的构造函数。在 JavaScript 中，由于构造函数可以像普通函数一样被调用，如果在调用构造函数时没有使用 `new` 关键字，那么 `this` 关键字将指向全局对象，这可能会导致意外的错误和行为不一致。



为了解决这个问题，可以使用作用域安全的构造函数。作用域安全的构造函数通常使用 `new` 关键字来调用构造函数，并且在内部使用条件语句来判断 `this` 关键字是否指向全局对象。如果是，它们会创建一个新的对象并将构造函数的属性和方法复制到该对象中，然后返回该对象，这样就可以确保 `this` 关键字指向正确的对象。



```js
function Person(name, age) {
  if (this instanceof Person) {
    this.name = name;
    this.age = age;
  } else {
    return new Person(name, age);
  }
}

var person1 = new Person('John', 30);
var person2 = Person('Jane', 25);

console.log(person1 instanceof Person); // 输出 true
console.log(person2 instanceof Person); // 输出 true

```



# 执行上下文

## 一、伪代码描述

```js
// 定义函数
function add(a, b) {
  // 创建函数执行上下文
  let functionContext = {
    // 变量对象
    VO: {
      a: undefined,
      b: undefined,
      sum: undefined
    },
    // 作用域链
    scopeChain: [VO, globalVO],
    // this 值
    thisValue: globalObject
  };

  // 初始化变量对象
  functionContext.VO.a = a;
  functionContext.VO.b = b;

  // 计算函数结果
  functionContext.VO.sum = a + b;

  // 返回结果
  return functionContext.VO.sum;
}

// 调用函数
add(1, 2);

```

## 二、分类

执行上下文是指在 JavaScript 中执行代码时，当前代码被解析和执行时所在的环境。在执行代码之前，JavaScript 引擎会创建一个执行上下文，用于存储变量、函数和对象等信息。执行上下文包括三种类型：

1. 全局执行上下文：在 JavaScript 代码中没有定义在任何函数内的变量和函数，都属于全局执行上下文。全局执行上下文只有一个，它会在整个脚本文件的生命周期中存在。
2. 函数执行上下文：在 JavaScript 代码中每当一个函数被调用时，都会创建一个函数执行上下文。函数执行上下文的生命周期是在函数被调用时开始，直到函数执行完毕时结束。
3. Eval 函数执行上下文：在 JavaScript 中可以通过 eval 函数动态执行代码。eval 函数执行的代码也有一个独立的执行上下文。

每个执行上下文都包含三个重要的属性：变量对象、作用域链和 this 值。其中变量对象用于存储函数和变量等信息，作用域链用于解析变量名和函数名，而 this 值用于引用当前函数执行的对象。

## 三、组成

### 1.全局执行上下文组成

在全局执行上下文中，有以下三个属性：

1. 变量对象（Variable Object）：全局执行上下文的变量对象是全局对象（Global Object），它是所有全局变量和函数的宿主对象。在浏览器中，全局对象是 window 对象，在 Node.js 环境中，全局对象是 global 对象。
2. 作用域链（Scope Chain）：全局执行上下文没有外部执行上下文，因此作用域链只包含一个变量对象，即全局对象。
3. this 值：在全局执行上下文中，this 值指向全局对象。在浏览器中，this 值是 window 对象，在 Node.js 环境中，this 值是 global 对象。

总之，全局执行上下文中的变量对象是全局对象，作用域链只包含一个变量对象，即全局对象，this 值指向全局对象。全局对象中包含了所有的全局变量和函数，因此它可以被任何地方的代码所访问。

### 2.函数上下文组成

函数执行上下文是在 JavaScript 代码中每当一个函数被调用时创建的上下文。在函数执行上下文中，有以下三个属性：

1. 变量对象（Variable Object）：函数执行上下文的变量对象包含了函数参数、内部变量、内部函数等信息。在函数执行之前，JavaScript 引擎会先创建一个变量对象，然后将函数的参数和内部变量添加到变量对象中。变量对象是一个与执行上下文相关的概念，它可以理解为存储变量和函数的地方。
2. 作用域链（Scope Chain）：在函数执行上下文中，作用域链用于解析变量和函数名。作用域链是由当前执行上下文的变量对象和所有外部执行上下文的作用域链构成的，它决定了在当前上下文中可以访问哪些变量和函数。
3. this 值：在函数执行上下文中，this 值指向函数被调用时的对象。this 的指向可以通过函数的调用方式来确定。

总之，函数执行上下文中的变量对象包含了函数参数、内部变量和函数等信息，作用域链用于解析变量和函数名，this 值指向函数被调用时的对象。这三个属性的值在函数执行期间会不断变化，直到函数执行结束并从执行栈中弹出时被销毁。



# 原型链实现继承

[推荐文章](https://juejin.cn/post/6844903475021627400)

